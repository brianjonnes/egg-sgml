<!doctype html><html><body>

<h1><!--                -->
Egg-SGML (PHP) </h1><p><!--
---------------------->

Egg-SGML is little more than a depth-first tree search routine. Its 
usefulness is in separating code from data. </p>

<h2><!--               -->
Overview: an interface between programmers and designers</h2><p><!--
---------------------->

In the turmoil which followed the discovery that HTML was based on a 
standard which was not freely available, a few things seem to have gotten 
lost. </p><p>

XML achieved two things: standardizing the underlying structure of HTML, 
and formalizing the document tree—something which SGML had brought about, 
but was rather lax over. </p><p>

However, the requirement of compatibility meant that web-browsers 
continued, and still continue, to accept as input whatever they can see their 
way to making something out of. The introduction of HTML5 was a declaration
of war against the strictness of XML. </p><p>

Egg-SGML contains a parser which is similar to a web browser's, but allows us
to expand on the document tree. This means that a reasonably competent web-developer
can fully control the look of a dynamic website without resorting to programme code. No constraints
are placed on the HTML or CSS. </p>

<h3>
Let me draw you a picture</h3><p><!--
----------------------->

As you know, parsing an HTML file builds a tree structure in memory: the document tree; so that it merely needs to be mentioned that the reverse of that process is called a <em>depth-first tree search</em>. That is, performing this search on a document tree outputs the document in HTML format. We now assume that the server is processing every HTML file in this fashion. </p><p>

The first thing that is likely to occur to someone who has built plain HTML websites is the addition of an &lt;include> tag. But this is not enough: often one is not able to separate headers and footers from the document easily, and the included file must be a complete document tree (in other words we cannot have &lt;body> in one file and &lt;/body> in another). </p><p>

What we can easily do is provide tags which store a subtree for later use, which we call &lt;record> and &lt;play>. When the &lt;record> tag is encountered, the server skips over its entire subtree. &lt;play> then adds this subtree back, and processes it as usual. If we use consistent identifiers in the files which include a common file, the common file will adapt wherever &lt;play> occurs. </p>

<h3>
Time for the block diagram</h3><p><!--
-------------------------->

We proceed from the description of a depth-first tree search routine. This routine in fact works on a stack, where each stack frame consists of a portion of a tree and a tag consumer. The tag consumer may add to this stack, such as happens with &lt;include> and &lt;play>. The result of stacking trees is a tree, so that we know our resulting document will be well-formed. </p>


<h2><!--              -->
Example </h2><p><!--
------------------>

A demonstration is necessary. If you have access to an Apache compatible 
webserver, with PHP (and mod_rewrite), setting up a clone of this repo as a 
virtual host should be all that's needed. </p>

Alternatively, these pages are hosted at 
<a href="https://egg-sgml.killtheworld.co.za/">
https://egg-sgml.killtheworld.co.za </a>.

<h2><!--            -->
Egg-SGML parser </h2><p><!--
---------------------->

As mentioned, a web browser doesn't complain when it receives a file which 
is non-conforming. Additionally, the developers of web browsers know very 
well that many webpages exist which are very old and do not have 
maintainers to upgrade them; thus pages conforming to old standards must 
continue to be parsed correctly. For this reason a web-browser must 
maintain a list of tags which formerly have been self-closing: hr, br, 
input, etc. </p><p>

<b>Egg-SGML does not include any legacy assumptions.</b> Always indicate a 
tag is self-closing: &lt;hr/>, &lt;br/>, etc. </p><p>

In contrast to XML, and more in line with a web browser's idea of HTML, 
attribute values may be single-quoted, double-quoted, or unquoted. Note 
that an unquoted attribute that ends with / must be succeeded by 
whitespace, or / will attach to >. For example, &lt;a href=/> is 
interpreted as &lt;a href="">&lt;/a>. </p><p>

In terms of document structure, unclosed tags are automatically closed when 
a tag that precedes it (encloses it) is closed. For example, 
"&lt;b>this &lt;i>sample&lt;/b>&lt;/i>" will be interpreted as 
"&lt;b>this &lt;i>sample<u>&lt;/i>&lt;/b></u>&amp;lt;/i>" and appear as 
"<b>this <i>sample</i></b>&lt;/i>": the unmatched closing tags are sent to 
the output as literal values. </p><p>

Finally, files must be UTF-8, and the zwnbsp byte order mark will be 
removed if found. </p>

<h2><!--           -->
Security considerations</h2><p><!--
---------------------->

Note that the included root tag consumer can load any file on the system, 
which the webserver process has access to. Additionally, the way .htaccess 
is setup here, any file with no extension, under your webroot, may be 
requested with templates.php, and will be processed as an Egg-SGML file. </p><p>

If you are going to include HTML from other sources, you must load a tag 
consumer that handles everything: tags must not devolve up the tag stack 
where tags such as 'include' will be allowed. </p>


</body></html>